"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _invariant = _interopRequireDefault(require("invariant"));

var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _hooks = require("../../hooks");

var _contexts = require("../../contexts");

var _bottomSheetContainer = _interopRequireDefault(require("../bottomSheetContainer"));

var _bottomSheetBackdropContainer = _interopRequireDefault(require("../bottomSheetBackdropContainer"));

var _bottomSheetHandleContainer = _interopRequireDefault(require("../bottomSheetHandleContainer"));

var _bottomSheetBackgroundContainer = _interopRequireDefault(require("../bottomSheetBackgroundContainer"));

var _bottomSheetDraggableView = _interopRequireDefault(require("../bottomSheetDraggableView"));

var _constants = require("../../constants");

var _utilities = require("../../utilities");

var _constants2 = require("./constants");

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import BottomSheetDebugView from '../bottomSheetDebugView';
_reactNativeReanimated.default.addWhitelistedUIProps({
  decelerationRate: true
});

const BottomSheetComponent = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  //#region validate props
  (0, _hooks.usePropsValidator)(props); //#endregion
  //#region extract props

  const {
    // animations configurations
    animationDuration: _providedAnimationDuration = _constants2.DEFAULT_ANIMATION_DURATION,
    animationEasing: _providedAnimationEasing = _constants2.DEFAULT_ANIMATION_EASING,
    animationConfigs: _providedAnimationConfigs,
    // configurations
    index: _providedIndex = 0,
    snapPoints: _providedSnapPoints,
    animateOnMount = _constants2.DEFAULT_ANIMATE_ON_MOUNT,
    enableContentPanningGesture = _constants2.DEFAULT_ENABLE_CONTENT_PANNING_GESTURE,
    enableHandlePanningGesture = _constants2.DEFAULT_ENABLE_HANDLE_PANNING_GESTURE,
    enableOverDrag = _constants2.DEFAULT_ENABLE_OVER_DRAG,
    enableFlashScrollableIndicatorOnExpand = _constants2.DEFAULT_ENABLE_FLASH_SCROLLABLE_INDICATOR_ON_EXPAND,
    style: _providedStyle,
    // keyboard
    keyboardBehavior = _constants2.DEFAULT_KEYBOARD_BEHAVIOR,
    keyboardBlurBehavior = _constants2.DEFAULT_KEYBOARD_BLUR_BEHAVIOR,
    // layout
    handleHeight: _providedHandleHeight,
    containerHeight: _providedContainerHeight,
    topInset = 0,
    overDragResistanceFactor = _constants2.DEFAULT_OVER_DRAG_RESISTANCE_FACTOR,
    // animated callback shared values
    animatedPosition: _providedAnimatedPosition,
    animatedIndex: _providedAnimatedIndex,
    // gestures
    simultaneousHandlers: _providedSimultaneousHandlers,
    waitFor: _providedWaitFor,
    activeOffsetX: _providedActiveOffsetX,
    activeOffsetY: _providedActiveOffsetY,
    failOffsetX: _providedFailOffsetX,
    failOffsetY: _providedFailOffsetY,
    // callbacks
    onChange: _providedOnChange,
    onAnimate: _providedOnAnimate,
    // components
    handleComponent,
    backdropComponent,
    backgroundComponent,
    children
  } = props; //#endregion
  //#region layout variables
  // state

  const [containerHeight, setContainerHeight] = (0, _react.useState)(_providedContainerHeight);
  const [handleHeight, setHandleHeight] = (0, _react.useState)(_providedHandleHeight); // safe layout values

  const safeHandleHeight = (0, _react.useMemo)(() => handleComponent === null ? 0 : handleHeight || _constants2.DEFAULT_HANDLE_HEIGHT, [handleHeight, handleComponent]);
  const safeContainerHeight = (0, _react.useMemo)(() => _providedContainerHeight || containerHeight || _constants.WINDOW_HEIGHT, [_providedContainerHeight, containerHeight]); // conditions

  const shouldMeasureContainerHeight = (0, _react.useMemo)(() => _providedContainerHeight === undefined, [_providedContainerHeight]);
  const shouldMeasureHandleHeight = (0, _react.useMemo)(() => _providedHandleHeight === undefined && handleComponent !== undefined && handleComponent !== null, [_providedHandleHeight, handleComponent]); // refs

  const didSetHandleHeight = (0, _react.useRef)(!shouldMeasureHandleHeight);
  const didSetContainerHeight = (0, _react.useRef)(!shouldMeasureContainerHeight);
  const isLayoutCalculated = (0, _react.useMemo)(() => {
    return didSetHandleHeight.current && didSetContainerHeight.current;
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [containerHeight, handleHeight]); //#endregion
  //#region variables

  const currentIndexRef = (0, _react.useRef)(animateOnMount ? -1 : _providedIndex);
  const isClosing = (0, _react.useRef)(false);
  const didMountOnAnimate = (0, _react.useRef)(false); // scrollable variables

  const {
    scrollableContentOffsetY,
    setScrollableRef,
    removeScrollableRef,
    flashScrollableIndicators
  } = (0, _hooks.useScrollable)(); // keyboard

  const isExtendedByKeyboard = (0, _reactNativeReanimated.useSharedValue)(false);
  const animatedKeyboardOffset = (0, _reactNativeReanimated.useSharedValue)(0);
  const {
    state: keyboardState,
    height: keyboardHeight,
    animationDuration: keyboardAnimationDuration,
    animationEasing: keyboardAnimationEasing,
    shouldHandleKeyboardEvents
  } = (0, _hooks.useKeyboard)(); // normalize snap points

  const snapPoints = (0, _hooks.useNormalizedSnapPoints)(_providedSnapPoints, topInset, safeContainerHeight, safeHandleHeight);
  const sheetHeight = (0, _react.useMemo)(() => safeContainerHeight - snapPoints[snapPoints.length - 1] - safeHandleHeight, [snapPoints, safeContainerHeight, safeHandleHeight]);
  const initialPosition = (0, _react.useMemo)(() => {
    return currentIndexRef.current < 0 || animateOnMount ? safeContainerHeight - topInset : snapPoints[currentIndexRef.current];
  }, [snapPoints, animateOnMount, safeContainerHeight, topInset]); //#endregion
  //#region private methods

  const refreshUIElements = (0, _react.useCallback)(() => {
    const currentPositionIndex = Math.max(currentIndexRef.current, 0);

    if (enableFlashScrollableIndicatorOnExpand && currentPositionIndex === snapPoints.length - 1) {
      flashScrollableIndicators();
    }
  }, [snapPoints, flashScrollableIndicators, enableFlashScrollableIndicatorOnExpand]);
  const handleOnChange = (0, _react.useCallback)(index => {
    if (index === currentIndexRef.current) {
      return;
    }

    currentIndexRef.current = index;

    if (isClosing.current && (index === 0 || index === -1)) {
      isClosing.current = false;
    }

    if (_providedOnChange) {
      /**
       * to avoid having -0 🤷‍♂️
       */
      _providedOnChange(index + 1 - 1);
    }
  }, [_providedOnChange]);
  const handleOnAnimate = (0, _react.useCallback)(toPoint => {
    if (!_providedOnAnimate) {
      return;
    }

    const toIndex = snapPoints.findIndex(item => item === toPoint);

    if (toIndex !== currentIndexRef.current) {
      _providedOnAnimate(currentIndexRef.current, toIndex);
    }
  }, [_providedOnAnimate, snapPoints]);
  const handleSettingScrollableRef = (0, _react.useCallback)(scrollableRef => {
    setScrollableRef(scrollableRef);
    refreshUIElements();
  }, [setScrollableRef, refreshUIElements]); //#endregion
  //#region gesture interaction / animation
  // variables

  const animatedSheetHeight = (0, _reactNativeReanimated.useDerivedValue)(() => {
    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.none || keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.extend) {
      return sheetHeight;
    }

    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.fullScreen) {
      return isExtendedByKeyboard.value ? safeContainerHeight - topInset - safeHandleHeight : sheetHeight;
    }

    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.interactive && isExtendedByKeyboard.value) {
      const safeFullScreenSheetHeight = safeContainerHeight - topInset - safeHandleHeight;
      const sheetWithKeyboardHeight = sheetHeight + keyboardHeight.value;

      if (keyboardState.value === _constants.KEYBOARD_STATE.SHOWN) {
        if (sheetHeight >= safeFullScreenSheetHeight) {
          return safeFullScreenSheetHeight - keyboardHeight.value;
        }

        return sheetHeight;
      }

      if (sheetWithKeyboardHeight > safeFullScreenSheetHeight) {
        return safeFullScreenSheetHeight;
      }

      return sheetWithKeyboardHeight;
    }

    return sheetHeight;
  });
  const animationState = (0, _reactNativeReanimated.useSharedValue)(_constants.ANIMATION_STATE.UNDETERMINED);
  const animatedSnapPoints = (0, _hooks.useReactiveSharedValue)(snapPoints);
  const animatedPosition = (0, _reactNativeReanimated.useSharedValue)(initialPosition);
  const animatedIndex = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const adjustedSnapPoints = snapPoints.slice().reverse();
    const adjustedSnapPointsIndexes = snapPoints.slice().map((_, index) => index).reverse();
    /**
     * we add the close state index `-1`
     */

    adjustedSnapPoints.push(safeContainerHeight);
    adjustedSnapPointsIndexes.push(-1);
    return isLayoutCalculated ? (0, _reactNativeReanimated.interpolate)(animatedPosition.value, adjustedSnapPoints, adjustedSnapPointsIndexes, _reactNativeReanimated.Extrapolate.CLAMP) : -1;
  }, [snapPoints, safeContainerHeight, isLayoutCalculated]);
  const animatedSheetState = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const extendedSheetPosition = safeContainerHeight - safeHandleHeight - sheetHeight;
    const extendedSheetWithKeyboardPosition = safeContainerHeight - safeHandleHeight - sheetHeight - keyboardHeight.value;

    if (animatedPosition.value >= safeContainerHeight) {
      return _constants.SHEET_STATE.CLOSED;
    } else if (animatedPosition.value === extendedSheetPosition || keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.interactive && isExtendedByKeyboard.value && animatedPosition.value === extendedSheetWithKeyboardPosition) {
      return _constants.SHEET_STATE.EXTENDED;
    } else if (animatedPosition.value === topInset) {
      return _constants.SHEET_STATE.FULL_SCREEN;
    } else if (animatedPosition.value < extendedSheetPosition) {
      return _constants.SHEET_STATE.OVER_EXTENDED;
    }

    return _constants.SHEET_STATE.OPENED;
  });
  const animatedCurrentIndex = (0, _reactNativeReanimated.useSharedValue)(currentIndexRef.current); // callbacks

  const animateToPointCompleted = (0, _reactNativeReanimated.useWorkletCallback)(() => {
    animationState.value = _constants.ANIMATION_STATE.STOPPED;
  });
  const animateToPoint = (0, _reactNativeReanimated.useWorkletCallback)((point, velocity = 0, configs) => {
    /**
     * cancel current running animation
     */
    (0, _reactNativeReanimated.cancelAnimation)(animatedPosition);
    /**
     * set animation state to running
     */

    animationState.value = _constants.ANIMATION_STATE.RUNNING;
    /**
     * fire `onAnimate` callback
     */

    (0, _reactNativeReanimated.runOnJS)(handleOnAnimate)(point);
    /**
     * force animation configs from parameters, if provided
     */

    if (configs !== undefined) {
      animatedPosition.value = (0, _utilities.animate)(point, configs, velocity, animateToPointCompleted);
    } else if (_providedAnimationConfigs) {
      /**
       * use animationConfigs callback, if provided
       */
      animatedPosition.value = (0, _utilities.animate)(point, _providedAnimationConfigs, velocity, animateToPointCompleted);
    } else {
      animatedPosition.value = (0, _utilities.animate)(point, {
        duration: _providedAnimationDuration,
        easing: _providedAnimationEasing
      }, 0, animateToPointCompleted);
    }
  }, [handleOnAnimate, _providedAnimationConfigs, _providedAnimationDuration, _providedAnimationEasing]);
  const scrollableState = (0, _reactNativeReanimated.useDerivedValue)(() => {
    return animatedSheetState.value === _constants.SHEET_STATE.FULL_SCREEN || animatedSheetState.value === _constants.SHEET_STATE.EXTENDED ? _constants.SCROLLABLE_STATE.UNLOCKED : _constants.SCROLLABLE_STATE.LOCKED;
  }); // hooks

  const [contentPanGestureHandler, contentPanGestureState] = (0, _hooks.useInteractivePanGestureHandler)({
    type: _constants.GESTURE.CONTENT,
    enableOverDrag,
    overDragResistanceFactor,
    keyboardState,
    keyboardHeight,
    keyboardBehavior: keyboardBehavior,
    animatedPosition,
    animatedSnapPoints,
    isExtendedByKeyboard,
    scrollableContentOffsetY,
    animateToPoint
  });
  const [handlePanGestureHandler, handlePanGestureState] = (0, _hooks.useInteractivePanGestureHandler)({
    type: _constants.GESTURE.HANDLE,
    enableOverDrag,
    overDragResistanceFactor,
    keyboardState,
    keyboardHeight,
    keyboardBehavior,
    animatedPosition,
    animatedSnapPoints,
    isExtendedByKeyboard,
    animateToPoint
  }); //#endregion
  //#region layout callbacks

  const handleOnContainerMeasureHeight = (0, _react.useCallback)(height => {
    // console.log('BottomSheet', 'handleOnContainerMeasureHeight', height);
    didSetContainerHeight.current = true;
    setContainerHeight(height);
  }, []);
  const handleOnHandleMeasureHeight = (0, _react.useCallback)(height => {
    // console.log('BottomSheet', 'handleOnHandleMeasureHeight', height);
    didSetHandleHeight.current = true;
    setHandleHeight(height);
  }, []); //#endregion
  //#region public methods

  const handleSnapTo = (0, _react.useCallback)((index, animationDuration = _constants2.DEFAULT_ANIMATION_DURATION, animationEasing = _constants2.DEFAULT_ANIMATION_EASING) => {
    (0, _invariant.default)(index >= -1 && index <= snapPoints.length - 1, `'index' was provided but out of the provided snap points range! expected value to be between -1, ${snapPoints.length - 1}`);
    /**
     * verify if sheet is closed.
     */

    if (animatedPosition.value === safeContainerHeight) {
      isClosing.current = false;
    }
    /**
     * exit method if sheet is closing.
     */


    if (isClosing.current) {
      return;
    }

    const newSnapPoint = snapPoints[index];
    (0, _reactNativeReanimated.runOnUI)(animateToPoint)(newSnapPoint, 0, {
      duration: animationDuration,
      easing: animationEasing
    });
  }, [animateToPoint, snapPoints, safeContainerHeight, animatedPosition]);
  const handleClose = (0, _react.useCallback)((animationDuration = _constants2.DEFAULT_ANIMATION_DURATION, animationEasing = _constants2.DEFAULT_ANIMATION_EASING) => {
    /**
     * verify if sheet is closed.
     */
    if (animatedPosition.value === safeContainerHeight) {
      isClosing.current = false;
    }
    /**
     * exit method if sheet is closing.
     */


    if (isClosing.current) {
      return;
    }

    isClosing.current = true;
    (0, _reactNativeReanimated.runOnUI)(animateToPoint)(safeContainerHeight, 0, {
      duration: animationDuration,
      easing: animationEasing
    });
  }, [animateToPoint, safeContainerHeight, animatedPosition]);
  const handleExpand = (0, _react.useCallback)((animationDuration = _constants2.DEFAULT_ANIMATION_DURATION, animationEasing = _constants2.DEFAULT_ANIMATION_EASING) => {
    /**
     * verify if sheet is closed.
     */
    if (animatedPosition.value === safeContainerHeight) {
      isClosing.current = false;
    }
    /**
     * exit method if sheet is closing.
     */


    if (isClosing.current) {
      return;
    }

    const newSnapPoint = snapPoints[snapPoints.length - 1];
    (0, _reactNativeReanimated.runOnUI)(animateToPoint)(newSnapPoint, 0, {
      duration: animationDuration,
      easing: animationEasing
    });
  }, [animateToPoint, snapPoints, safeContainerHeight, animatedPosition]);
  const handleCollapse = (0, _react.useCallback)((animationDuration = _constants2.DEFAULT_ANIMATION_DURATION, animationEasing = _constants2.DEFAULT_ANIMATION_EASING) => {
    /**
     * verify if sheet is closed.
     */
    if (animatedPosition.value === safeContainerHeight) {
      isClosing.current = false;
    }
    /**
     * exit method if sheet is closing.
     */


    if (isClosing.current) {
      return;
    }

    const newSnapPoint = snapPoints[0];
    (0, _reactNativeReanimated.runOnUI)(animateToPoint)(newSnapPoint, 0, {
      duration: animationDuration,
      easing: animationEasing
    });
  }, [animateToPoint, snapPoints, safeContainerHeight, animatedPosition]);
  (0, _react.useImperativeHandle)(ref, () => ({
    snapTo: handleSnapTo,
    expand: handleExpand,
    collapse: handleCollapse,
    close: handleClose
  })); //#endregion
  //#region contexts variables

  const internalContextVariables = (0, _react.useMemo)(() => ({
    enableContentPanningGesture,
    snapPointsCount: snapPoints.length,
    animatedIndex,
    animatedPosition,
    animationState,
    animatedSheetState,
    contentPanGestureHandler,
    scrollableState,
    scrollableContentOffsetY,
    shouldHandleKeyboardEvents,
    simultaneousHandlers: _providedSimultaneousHandlers,
    waitFor: _providedWaitFor,
    activeOffsetX: _providedActiveOffsetX,
    activeOffsetY: _providedActiveOffsetY,
    failOffsetX: _providedFailOffsetX,
    failOffsetY: _providedFailOffsetY,
    setScrollableRef: handleSettingScrollableRef,
    removeScrollableRef
  }), [snapPoints.length, animatedIndex, animatedPosition, animationState, animatedSheetState, contentPanGestureHandler, handleSettingScrollableRef, removeScrollableRef, shouldHandleKeyboardEvents, scrollableState, scrollableContentOffsetY, enableContentPanningGesture, _providedSimultaneousHandlers, _providedWaitFor, _providedActiveOffsetX, _providedActiveOffsetY, _providedFailOffsetX, _providedFailOffsetY]);
  const externalContextVariables = (0, _react.useMemo)(() => ({
    snapTo: handleSnapTo,
    expand: handleExpand,
    collapse: handleCollapse,
    close: handleClose
  }), [handleSnapTo, handleExpand, handleCollapse, handleClose]); //#endregion
  //#region styles

  const containerAnimatedStyle = (0, _reactNativeReanimated.useAnimatedStyle)(() => {
    return {
      opacity: isLayoutCalculated ? 1 : 0,
      transform: [{
        translateY: isLayoutCalculated ? Math.max(animatedPosition.value + animatedKeyboardOffset.value, topInset) : safeContainerHeight
      }]
    };
  }, [safeContainerHeight, isLayoutCalculated, animatedKeyboardOffset, topInset]);
  const containerStyle = (0, _react.useMemo)(() => [_providedStyle, _styles.styles.container, containerAnimatedStyle], [_providedStyle, containerAnimatedStyle]);
  const contentContainerAnimatedStyle = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    height: animatedSheetHeight.value
  }), []);
  const contentContainerStyle = (0, _react.useMemo)(() => [_styles.styles.contentContainer, contentContainerAnimatedStyle], [contentContainerAnimatedStyle]);
  /**
   * added safe area to prevent the sheet from floating above
   * the bottom of the screen, when sheet being over dragged or
   * when the sheet is resized.
   */

  const contentMaskContainerStyle = (0, _react.useMemo)(() => ({ ..._styles.styles.contentMaskContainer,
    paddingBottom: sheetHeight
  }), [sheetHeight]); //#endregion
  //#region effects

  /**
   * This will animate the sheet to the initial snap point
   * when component is mounted.
   */

  (0, _react.useLayoutEffect)(() => {
    if (animateOnMount && isLayoutCalculated && didMountOnAnimate.current === false && isClosing.current === false && snapPoints[_providedIndex] !== safeContainerHeight && _providedIndex !== -1) {
      const newSnapPoint = snapPoints[_providedIndex];
      requestAnimationFrame(() => (0, _reactNativeReanimated.runOnUI)(animateToPoint)(newSnapPoint));
      didMountOnAnimate.current = true;
    }
  }, [_providedIndex, animateOnMount, isLayoutCalculated, snapPoints, safeContainerHeight, animateToPoint]);
  /*
   * keep animated position synced with snap points.
   */

  (0, _react.useEffect)(() => {
    if (isLayoutCalculated && currentIndexRef.current !== -1 && isClosing.current === false) {
      /**
       * Set index to new the snap points length, if previous index
       * is out of bond.
       */
      const safeCurrentIndex = Math.min(currentIndexRef.current, snapPoints.length - 1);
      const newSnapPoint = snapPoints[safeCurrentIndex];
      requestAnimationFrame(() => (0, _reactNativeReanimated.runOnUI)(animateToPoint)(newSnapPoint));
    }
  }, [isLayoutCalculated, snapPoints, animateToPoint]);
  /**
   * handle keyboard appearance behavior
   */

  (0, _reactNativeReanimated.useAnimatedReaction)(() => keyboardState.value, (state, previousState) => {
    if (state === previousState) {
      return;
    }

    let animationConfigs = (0, _utilities.getKeyboardAnimationConfigs)(keyboardAnimationEasing.value, keyboardAnimationDuration.value);
    /**
     * Handle restore sheet position on blur
     */

    if (keyboardBlurBehavior === _constants.KEYBOARD_BLUR_BEHAVIOR.restore && state === _constants.KEYBOARD_STATE.HIDDEN && contentPanGestureState.value !== _reactNativeGestureHandler.State.ACTIVE && handlePanGestureState.value !== _reactNativeGestureHandler.State.ACTIVE) {
      isExtendedByKeyboard.value = false;
      const newSnapPoint = snapPoints[animatedCurrentIndex.value];
      animateToPoint(newSnapPoint, 0, animationConfigs);
    }
    /**
     * Handle extend behavior
     */


    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.extend && state === _constants.KEYBOARD_STATE.SHOWN) {
      const newSnapPoint = snapPoints[snapPoints.length - 1];
      animateToPoint(newSnapPoint, 0, animationConfigs);
      return;
    }
    /**
     * Handle full screen behavior
     */


    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.fullScreen && state === _constants.KEYBOARD_STATE.SHOWN) {
      isExtendedByKeyboard.value = true;
      animateToPoint(topInset, 0, animationConfigs);
      return;
    }
    /**
     * handle interactive behavior
     */


    if (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.interactive && state === _constants.KEYBOARD_STATE.SHOWN) {
      isExtendedByKeyboard.value = true;
      const newSnapPoint = snapPoints[snapPoints.length - 1];
      animateToPoint(Math.max(topInset, newSnapPoint - keyboardHeight.value), 0, animationConfigs);
    }
  });
  /**
   * sets provided animated position
   */

  (0, _reactNativeReanimated.useAnimatedReaction)(() => animatedPosition.value, value => {
    if (_providedAnimatedPosition) {
      _providedAnimatedPosition.value = value;
    }
  });
  /**
   * sets provided animated index
   */

  (0, _reactNativeReanimated.useAnimatedReaction)(() => animatedIndex.value, value => {
    if (_providedAnimatedIndex) {
      _providedAnimatedIndex.value = value;
    }
  });
  /**
   * reaction to trigger `handleOnChange`
   */

  (0, _reactNativeReanimated.useAnimatedReaction)(() => ({
    _animatedIndex: animatedIndex.value,
    _animatedPosition: animatedPosition.value,
    _animationState: animationState.value,
    _contentGestureState: contentPanGestureState.value,
    _handleGestureState: handlePanGestureState.value
  }), ({
    _animatedIndex,
    _animationState,
    _contentGestureState,
    _handleGestureState
  }) => {
    if (_animatedIndex % 1 === 0 && _animationState === _constants.ANIMATION_STATE.STOPPED && (_contentGestureState === _reactNativeGestureHandler.State.END || _contentGestureState === _reactNativeGestureHandler.State.UNDETERMINED) && (_handleGestureState === _reactNativeGestureHandler.State.END || _handleGestureState === _reactNativeGestureHandler.State.UNDETERMINED)) {
      animatedCurrentIndex.value = animatedIndex.value;
      (0, _reactNativeReanimated.runOnJS)(handleOnChange)(animatedIndex.value);
      (0, _reactNativeReanimated.runOnJS)(refreshUIElements)();
    }
  }, [handleOnChange]); //#endregion
  // render
  // console.log(
  //   'BottomSheet',
  //   'render',
  //   snapPoints,
  //   safeContainerHeight,
  //   safeHandleHeight,
  //   sheetHeight
  // );

  return /*#__PURE__*/_react.default.createElement(_contexts.BottomSheetProvider, {
    value: externalContextVariables
  }, /*#__PURE__*/_react.default.createElement(_bottomSheetBackdropContainer.default, {
    key: "BottomSheetBackdropContainer",
    animatedIndex: animatedIndex,
    animatedPosition: animatedPosition,
    backdropComponent: backdropComponent
  }), /*#__PURE__*/_react.default.createElement(_bottomSheetContainer.default, {
    key: "BottomSheetContainer",
    containerHeight: safeContainerHeight,
    shouldMeasureHeight: shouldMeasureContainerHeight,
    onMeasureHeight: handleOnContainerMeasureHeight
  }, /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    accessible: true,
    accessibilityRole: "adjustable",
    accessibilityLabel: "Bottom Sheet",
    style: containerStyle
  }, /*#__PURE__*/_react.default.createElement(_contexts.BottomSheetInternalProvider, {
    value: internalContextVariables
  }, /*#__PURE__*/_react.default.createElement(_bottomSheetBackgroundContainer.default, {
    key: "BottomSheetBackgroundContainer",
    animatedIndex: animatedIndex,
    animatedPosition: animatedPosition,
    backgroundComponent: backgroundComponent
  }), /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    pointerEvents: "box-none",
    style: contentMaskContainerStyle
  }, isLayoutCalculated && /*#__PURE__*/_react.default.createElement(_bottomSheetDraggableView.default, {
    key: "BottomSheetRootDraggableView",
    style: contentContainerStyle
  }, typeof children === 'function' ? children() : children)), /*#__PURE__*/_react.default.createElement(_bottomSheetHandleContainer.default, {
    key: "BottomSheetHandleContainer",
    animatedIndex: animatedIndex,
    animatedPosition: animatedPosition,
    shouldMeasureHeight: shouldMeasureHandleHeight,
    enableHandlePanningGesture: enableHandlePanningGesture,
    handlePanGestureHandler: handlePanGestureHandler,
    handleComponent: handleComponent,
    snapPoints: snapPoints,
    onMeasureHeight: handleOnHandleMeasureHeight
  })))));
});
const BottomSheet = /*#__PURE__*/(0, _react.memo)(BottomSheetComponent);
BottomSheet.displayName = 'BottomSheet';
var _default = BottomSheet;
exports.default = _default;
//# sourceMappingURL=BottomSheet.js.map