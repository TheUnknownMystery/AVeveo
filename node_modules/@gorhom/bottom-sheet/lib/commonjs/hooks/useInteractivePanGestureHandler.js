"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInteractivePanGestureHandler = void 0;

var _reactNative = require("react-native");

var _reactNativeReanimated = require("react-native-reanimated");

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _reactNativeRedash = require("react-native-redash");

var _constants = require("../constants");

const useInteractivePanGestureHandler = ({
  type,
  enableOverDrag,
  overDragResistanceFactor,
  keyboardState,
  keyboardBehavior,
  keyboardHeight,
  isExtendedByKeyboard,
  animatedPosition,
  animatedSnapPoints,
  scrollableContentOffsetY,
  animateToPoint
}) => {
  const gestureState = (0, _reactNativeReanimated.useSharedValue)(_reactNativeGestureHandler.State.UNDETERMINED);
  const gestureTranslationY = (0, _reactNativeReanimated.useSharedValue)(0);
  const gestureVelocityY = (0, _reactNativeReanimated.useSharedValue)(0);
  const gestureHandler = (0, _reactNativeReanimated.useAnimatedGestureHandler)({
    onStart: ({
      state,
      translationY,
      velocityY
    }, context) => {
      // cancel current animation
      (0, _reactNativeReanimated.cancelAnimation)(animatedPosition); // store current animated position

      context.currentPosition = animatedPosition.value;
      context.keyboardState = keyboardState.value;

      if (keyboardState.value === _constants.KEYBOARD_STATE.SHOWN && (keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.interactive || keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.fullScreen)) {
        isExtendedByKeyboard.value = true;
      } // set variables


      gestureState.value = state;
      gestureTranslationY.value = translationY;
      gestureVelocityY.value = velocityY;
    },
    onActive: ({
      state,
      translationY,
      velocityY,
      absoluteY
    }, context) => {
      gestureState.value = state;
      gestureTranslationY.value = translationY;
      gestureVelocityY.value = velocityY;
      const position = context.currentPosition + translationY;
      const maxSnapPoint = isExtendedByKeyboard.value ? context.currentPosition : animatedSnapPoints.value[animatedSnapPoints.value.length - 1];
      const negativeScrollableContentOffset = context.currentPosition === maxSnapPoint && scrollableContentOffsetY ? scrollableContentOffsetY.value * -1 : 0;
      const clampedPosition = (0, _reactNativeRedash.clamp)(position + negativeScrollableContentOffset, maxSnapPoint, animatedSnapPoints.value[0]);
      /**
       * dismiss the keyboard when panning down
       */

      if (translationY > _constants.KEYBOARD_DISMISS_THRESHOLD) {
        if (keyboardState.value === _constants.KEYBOARD_STATE.SHOWN && (_reactNative.Platform.OS === 'android' || keyboardBehavior !== _constants.KEYBOARD_BEHAVIOR.interactive || keyboardBehavior === _constants.KEYBOARD_BEHAVIOR.interactive && absoluteY < _constants.WINDOW_HEIGHT - keyboardHeight.value)) {
          (0, _reactNativeReanimated.runOnJS)(_reactNative.Keyboard.dismiss)();
        }
      }

      if (enableOverDrag) {
        if (type === _constants.GESTURE.HANDLE && position <= maxSnapPoint) {
          const resistedPosition = maxSnapPoint - Math.sqrt(1 + (maxSnapPoint - position)) * overDragResistanceFactor;
          animatedPosition.value = resistedPosition;
          return;
        }

        if (type === _constants.GESTURE.HANDLE && position > animatedSnapPoints.value[0]) {
          const resistedPosition = animatedSnapPoints.value[0] + Math.sqrt(1 + (position - animatedSnapPoints.value[0])) * overDragResistanceFactor;
          animatedPosition.value = resistedPosition;
          return;
        }

        if (type === _constants.GESTURE.CONTENT && position + negativeScrollableContentOffset > animatedSnapPoints.value[0]) {
          const resistedPosition = animatedSnapPoints.value[0] + Math.sqrt(1 + (position + negativeScrollableContentOffset - animatedSnapPoints.value[0])) * overDragResistanceFactor;
          animatedPosition.value = resistedPosition;
          return;
        }
      }

      animatedPosition.value = clampedPosition;
    },
    onEnd: ({
      state
    }, context) => {
      gestureState.value = state;

      if (isExtendedByKeyboard.value && context.currentPosition >= animatedPosition.value) {
        if (context.currentPosition > animatedPosition.value) {
          animateToPoint(context.currentPosition, gestureVelocityY.value / 2);
        }

        return;
      }

      if (isExtendedByKeyboard.value) {
        isExtendedByKeyboard.value = false;
      }

      const destinationPoint = (0, _reactNativeRedash.snapPoint)(gestureTranslationY.value + context.currentPosition, gestureVelocityY.value, animatedSnapPoints.value);
      /**
       * if destination point is the same as the current position,
       * then no need to perform animation.
       */

      if (destinationPoint === animatedPosition.value) {
        return;
      }

      if ((scrollableContentOffsetY ? scrollableContentOffsetY.value : 0) > 0 && context.currentPosition === animatedSnapPoints.value[animatedSnapPoints.value.length - 1] && animatedPosition.value === animatedSnapPoints.value[animatedSnapPoints.value.length - 1]) {
        return;
      }

      animateToPoint(destinationPoint, gestureVelocityY.value / 2);
    },
    onCancel: ({
      state
    }) => {
      gestureState.value = state;
    },
    onFail: ({
      state
    }) => {
      gestureState.value = state;
    },
    onFinish: ({
      state
    }) => {
      gestureState.value = state;
    }
  });
  return [gestureHandler, gestureState, gestureTranslationY, gestureVelocityY];
};

exports.useInteractivePanGestureHandler = useInteractivePanGestureHandler;
//# sourceMappingURL=useInteractivePanGestureHandler.js.map