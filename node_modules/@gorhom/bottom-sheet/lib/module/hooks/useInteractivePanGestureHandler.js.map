{"version":3,"sources":["useInteractivePanGestureHandler.ts"],"names":["Keyboard","Platform","useAnimatedGestureHandler","useSharedValue","cancelAnimation","runOnJS","State","clamp","snapPoint","GESTURE","KEYBOARD_BEHAVIOR","KEYBOARD_DISMISS_THRESHOLD","KEYBOARD_STATE","WINDOW_HEIGHT","useInteractivePanGestureHandler","type","enableOverDrag","overDragResistanceFactor","keyboardState","keyboardBehavior","keyboardHeight","isExtendedByKeyboard","animatedPosition","animatedSnapPoints","scrollableContentOffsetY","animateToPoint","gestureState","UNDETERMINED","gestureTranslationY","gestureVelocityY","gestureHandler","onStart","state","translationY","velocityY","context","currentPosition","value","SHOWN","interactive","fullScreen","onActive","absoluteY","position","maxSnapPoint","length","negativeScrollableContentOffset","clampedPosition","OS","dismiss","HANDLE","resistedPosition","Math","sqrt","CONTENT","onEnd","destinationPoint","onCancel","onFail","onFinish"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,QAAnB,QAAmC,cAAnC;AACA,SACEC,yBADF,EAEEC,cAFF,EAGEC,eAHF,EAIEC,OAJF,QAKO,yBALP;AAMA,SACEC,KADF,QAGO,8BAHP;AAIA,SAASC,KAAT,EAAgBC,SAAhB,QAAiC,qBAAjC;AACA,SACEC,OADF,EAEEC,iBAFF,EAGEC,0BAHF,EAIEC,cAJF,EAKEC,aALF,QAMO,cANP;AA2BA,OAAO,MAAMC,+BAA+B,GAAG,CAAC;AAC9CC,EAAAA,IAD8C;AAE9CC,EAAAA,cAF8C;AAG9CC,EAAAA,wBAH8C;AAI9CC,EAAAA,aAJ8C;AAK9CC,EAAAA,gBAL8C;AAM9CC,EAAAA,cAN8C;AAO9CC,EAAAA,oBAP8C;AAQ9CC,EAAAA,gBAR8C;AAS9CC,EAAAA,kBAT8C;AAU9CC,EAAAA,wBAV8C;AAW9CC,EAAAA;AAX8C,CAAD,KAiB1C;AACH,QAAMC,YAAY,GAAGvB,cAAc,CAAQG,KAAK,CAACqB,YAAd,CAAnC;AACA,QAAMC,mBAAmB,GAAGzB,cAAc,CAAC,CAAD,CAA1C;AACA,QAAM0B,gBAAgB,GAAG1B,cAAc,CAAC,CAAD,CAAvC;AAEA,QAAM2B,cAAc,GAAG5B,yBAAyB,CAG9C;AACA6B,IAAAA,OAAO,EAAE,CAAC;AAAEC,MAAAA,KAAF;AAASC,MAAAA,YAAT;AAAuBC,MAAAA;AAAvB,KAAD,EAAqCC,OAArC,KAAiD;AACxD;AACA/B,MAAAA,eAAe,CAACkB,gBAAD,CAAf,CAFwD,CAIxD;;AACAa,MAAAA,OAAO,CAACC,eAAR,GAA0Bd,gBAAgB,CAACe,KAA3C;AACAF,MAAAA,OAAO,CAACjB,aAAR,GAAwBA,aAAa,CAACmB,KAAtC;;AAEA,UACEnB,aAAa,CAACmB,KAAd,KAAwBzB,cAAc,CAAC0B,KAAvC,KACCnB,gBAAgB,KAAKT,iBAAiB,CAAC6B,WAAvC,IACCpB,gBAAgB,KAAKT,iBAAiB,CAAC8B,UAFzC,CADF,EAIE;AACAnB,QAAAA,oBAAoB,CAACgB,KAArB,GAA6B,IAA7B;AACD,OAduD,CAgBxD;;;AACAX,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;AACAJ,MAAAA,mBAAmB,CAACS,KAApB,GAA4BJ,YAA5B;AACAJ,MAAAA,gBAAgB,CAACQ,KAAjB,GAAyBH,SAAzB;AACD,KArBD;AAsBAO,IAAAA,QAAQ,EAAE,CAAC;AAAET,MAAAA,KAAF;AAASC,MAAAA,YAAT;AAAuBC,MAAAA,SAAvB;AAAkCQ,MAAAA;AAAlC,KAAD,EAAgDP,OAAhD,KAA4D;AACpET,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;AACAJ,MAAAA,mBAAmB,CAACS,KAApB,GAA4BJ,YAA5B;AACAJ,MAAAA,gBAAgB,CAACQ,KAAjB,GAAyBH,SAAzB;AAEA,YAAMS,QAAQ,GAAGR,OAAO,CAACC,eAAR,GAA0BH,YAA3C;AACA,YAAMW,YAAY,GAAGvB,oBAAoB,CAACgB,KAArB,GACjBF,OAAO,CAACC,eADS,GAEjBb,kBAAkB,CAACc,KAAnB,CAAyBd,kBAAkB,CAACc,KAAnB,CAAyBQ,MAAzB,GAAkC,CAA3D,CAFJ;AAIA,YAAMC,+BAA+B,GACnCX,OAAO,CAACC,eAAR,KAA4BQ,YAA5B,IAA4CpB,wBAA5C,GACIA,wBAAwB,CAACa,KAAzB,GAAiC,CAAC,CADtC,GAEI,CAHN;AAIA,YAAMU,eAAe,GAAGxC,KAAK,CAC3BoC,QAAQ,GAAGG,+BADgB,EAE3BF,YAF2B,EAG3BrB,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,CAH2B,CAA7B;AAMA;AACN;AACA;;AACM,UAAIJ,YAAY,GAAGtB,0BAAnB,EAA+C;AAC7C,YACEO,aAAa,CAACmB,KAAd,KAAwBzB,cAAc,CAAC0B,KAAvC,KACCrC,QAAQ,CAAC+C,EAAT,KAAgB,SAAhB,IACC7B,gBAAgB,KAAKT,iBAAiB,CAAC6B,WADxC,IAEEpB,gBAAgB,KAAKT,iBAAiB,CAAC6B,WAAvC,IACCG,SAAS,GAAG7B,aAAa,GAAGO,cAAc,CAACiB,KAJ/C,CADF,EAME;AACAhC,UAAAA,OAAO,CAACL,QAAQ,CAACiD,OAAV,CAAP;AACD;AACF;;AAED,UAAIjC,cAAJ,EAAoB;AAClB,YAAID,IAAI,KAAKN,OAAO,CAACyC,MAAjB,IAA2BP,QAAQ,IAAIC,YAA3C,EAAyD;AACvD,gBAAMO,gBAAgB,GACpBP,YAAY,GACZQ,IAAI,CAACC,IAAL,CAAU,KAAKT,YAAY,GAAGD,QAApB,CAAV,IAA2C1B,wBAF7C;AAGAK,UAAAA,gBAAgB,CAACe,KAAjB,GAAyBc,gBAAzB;AACA;AACD;;AAED,YAAIpC,IAAI,KAAKN,OAAO,CAACyC,MAAjB,IAA2BP,QAAQ,GAAGpB,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,CAA1C,EAAuE;AACrE,gBAAMc,gBAAgB,GACpB5B,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,IACAe,IAAI,CAACC,IAAL,CAAU,KAAKV,QAAQ,GAAGpB,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,CAAhB,CAAV,IACEpB,wBAHJ;AAIAK,UAAAA,gBAAgB,CAACe,KAAjB,GAAyBc,gBAAzB;AACA;AACD;;AAED,YACEpC,IAAI,KAAKN,OAAO,CAAC6C,OAAjB,IACAX,QAAQ,GAAGG,+BAAX,GACEvB,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,CAHJ,EAIE;AACA,gBAAMc,gBAAgB,GACpB5B,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,IACAe,IAAI,CAACC,IAAL,CACE,KACGV,QAAQ,GACPG,+BADD,GAECvB,kBAAkB,CAACc,KAAnB,CAAyB,CAAzB,CAHJ,CADF,IAMEpB,wBARJ;AASAK,UAAAA,gBAAgB,CAACe,KAAjB,GAAyBc,gBAAzB;AACA;AACD;AACF;;AAED7B,MAAAA,gBAAgB,CAACe,KAAjB,GAAyBU,eAAzB;AACD,KA/FD;AAgGAQ,IAAAA,KAAK,EAAE,CAAC;AAAEvB,MAAAA;AAAF,KAAD,EAAYG,OAAZ,KAAwB;AAC7BT,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;;AAEA,UACEX,oBAAoB,CAACgB,KAArB,IACAF,OAAO,CAACC,eAAR,IAA2Bd,gBAAgB,CAACe,KAF9C,EAGE;AACA,YAAIF,OAAO,CAACC,eAAR,GAA0Bd,gBAAgB,CAACe,KAA/C,EAAsD;AACpDZ,UAAAA,cAAc,CAACU,OAAO,CAACC,eAAT,EAA0BP,gBAAgB,CAACQ,KAAjB,GAAyB,CAAnD,CAAd;AACD;;AACD;AACD;;AAED,UAAIhB,oBAAoB,CAACgB,KAAzB,EAAgC;AAC9BhB,QAAAA,oBAAoB,CAACgB,KAArB,GAA6B,KAA7B;AACD;;AAED,YAAMmB,gBAAgB,GAAGhD,SAAS,CAChCoB,mBAAmB,CAACS,KAApB,GAA4BF,OAAO,CAACC,eADJ,EAEhCP,gBAAgB,CAACQ,KAFe,EAGhCd,kBAAkB,CAACc,KAHa,CAAlC;AAMA;AACN;AACA;AACA;;AACM,UAAImB,gBAAgB,KAAKlC,gBAAgB,CAACe,KAA1C,EAAiD;AAC/C;AACD;;AAED,UACE,CAACb,wBAAwB,GAAGA,wBAAwB,CAACa,KAA5B,GAAoC,CAA7D,IAAkE,CAAlE,IACAF,OAAO,CAACC,eAAR,KACEb,kBAAkB,CAACc,KAAnB,CAAyBd,kBAAkB,CAACc,KAAnB,CAAyBQ,MAAzB,GAAkC,CAA3D,CAFF,IAGAvB,gBAAgB,CAACe,KAAjB,KACEd,kBAAkB,CAACc,KAAnB,CAAyBd,kBAAkB,CAACc,KAAnB,CAAyBQ,MAAzB,GAAkC,CAA3D,CALJ,EAME;AACA;AACD;;AAEDpB,MAAAA,cAAc,CAAC+B,gBAAD,EAAmB3B,gBAAgB,CAACQ,KAAjB,GAAyB,CAA5C,CAAd;AACD,KA1ID;AA2IAoB,IAAAA,QAAQ,EAAE,CAAC;AAAEzB,MAAAA;AAAF,KAAD,KAAe;AACvBN,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;AACD,KA7ID;AA8IA0B,IAAAA,MAAM,EAAE,CAAC;AAAE1B,MAAAA;AAAF,KAAD,KAAe;AACrBN,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;AACD,KAhJD;AAiJA2B,IAAAA,QAAQ,EAAE,CAAC;AAAE3B,MAAAA;AAAF,KAAD,KAAe;AACvBN,MAAAA,YAAY,CAACW,KAAb,GAAqBL,KAArB;AACD;AAnJD,GAH8C,CAAhD;AAyJA,SAAO,CAACF,cAAD,EAAiBJ,YAAjB,EAA+BE,mBAA/B,EAAoDC,gBAApD,CAAP;AACD,CAhLM","sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport Animated, {\n  useAnimatedGestureHandler,\n  useSharedValue,\n  cancelAnimation,\n  runOnJS,\n} from 'react-native-reanimated';\nimport {\n  State,\n  PanGestureHandlerGestureEvent,\n} from 'react-native-gesture-handler';\nimport { clamp, snapPoint } from 'react-native-redash';\nimport {\n  GESTURE,\n  KEYBOARD_BEHAVIOR,\n  KEYBOARD_DISMISS_THRESHOLD,\n  KEYBOARD_STATE,\n  WINDOW_HEIGHT,\n} from '../constants';\n\ninterface useInteractivePanGestureHandlerConfigs {\n  type: GESTURE;\n  enableOverDrag: boolean;\n  overDragResistanceFactor: number;\n  isExtendedByKeyboard: Animated.SharedValue<boolean>;\n  keyboardState: Animated.SharedValue<KEYBOARD_STATE>;\n  keyboardHeight: Animated.SharedValue<number>;\n  keyboardBehavior: keyof typeof KEYBOARD_BEHAVIOR;\n  animatedSnapPoints: Animated.SharedValue<number[]>;\n  animatedPosition: Animated.SharedValue<number>;\n  scrollableContentOffsetY?: Animated.SharedValue<number>;\n  animateToPoint: (point: number, velocity: number) => void;\n}\n\ntype InteractivePanGestureHandlerContextType = {\n  currentPosition: number;\n  keyboardState: KEYBOARD_STATE;\n};\n\nexport const useInteractivePanGestureHandler = ({\n  type,\n  enableOverDrag,\n  overDragResistanceFactor,\n  keyboardState,\n  keyboardBehavior,\n  keyboardHeight,\n  isExtendedByKeyboard,\n  animatedPosition,\n  animatedSnapPoints,\n  scrollableContentOffsetY,\n  animateToPoint,\n}: useInteractivePanGestureHandlerConfigs): [\n  (event: PanGestureHandlerGestureEvent) => void,\n  Animated.SharedValue<State>,\n  Animated.SharedValue<number>,\n  Animated.SharedValue<number>\n] => {\n  const gestureState = useSharedValue<State>(State.UNDETERMINED);\n  const gestureTranslationY = useSharedValue(0);\n  const gestureVelocityY = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<\n    PanGestureHandlerGestureEvent,\n    InteractivePanGestureHandlerContextType\n  >({\n    onStart: ({ state, translationY, velocityY }, context) => {\n      // cancel current animation\n      cancelAnimation(animatedPosition);\n\n      // store current animated position\n      context.currentPosition = animatedPosition.value;\n      context.keyboardState = keyboardState.value;\n\n      if (\n        keyboardState.value === KEYBOARD_STATE.SHOWN &&\n        (keyboardBehavior === KEYBOARD_BEHAVIOR.interactive ||\n          keyboardBehavior === KEYBOARD_BEHAVIOR.fullScreen)\n      ) {\n        isExtendedByKeyboard.value = true;\n      }\n\n      // set variables\n      gestureState.value = state;\n      gestureTranslationY.value = translationY;\n      gestureVelocityY.value = velocityY;\n    },\n    onActive: ({ state, translationY, velocityY, absoluteY }, context) => {\n      gestureState.value = state;\n      gestureTranslationY.value = translationY;\n      gestureVelocityY.value = velocityY;\n\n      const position = context.currentPosition + translationY;\n      const maxSnapPoint = isExtendedByKeyboard.value\n        ? context.currentPosition\n        : animatedSnapPoints.value[animatedSnapPoints.value.length - 1];\n\n      const negativeScrollableContentOffset =\n        context.currentPosition === maxSnapPoint && scrollableContentOffsetY\n          ? scrollableContentOffsetY.value * -1\n          : 0;\n      const clampedPosition = clamp(\n        position + negativeScrollableContentOffset,\n        maxSnapPoint,\n        animatedSnapPoints.value[0]\n      );\n\n      /**\n       * dismiss the keyboard when panning down\n       */\n      if (translationY > KEYBOARD_DISMISS_THRESHOLD) {\n        if (\n          keyboardState.value === KEYBOARD_STATE.SHOWN &&\n          (Platform.OS === 'android' ||\n            keyboardBehavior !== KEYBOARD_BEHAVIOR.interactive ||\n            (keyboardBehavior === KEYBOARD_BEHAVIOR.interactive &&\n              absoluteY < WINDOW_HEIGHT - keyboardHeight.value))\n        ) {\n          runOnJS(Keyboard.dismiss)();\n        }\n      }\n\n      if (enableOverDrag) {\n        if (type === GESTURE.HANDLE && position <= maxSnapPoint) {\n          const resistedPosition =\n            maxSnapPoint -\n            Math.sqrt(1 + (maxSnapPoint - position)) * overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (type === GESTURE.HANDLE && position > animatedSnapPoints.value[0]) {\n          const resistedPosition =\n            animatedSnapPoints.value[0] +\n            Math.sqrt(1 + (position - animatedSnapPoints.value[0])) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (\n          type === GESTURE.CONTENT &&\n          position + negativeScrollableContentOffset >\n            animatedSnapPoints.value[0]\n        ) {\n          const resistedPosition =\n            animatedSnapPoints.value[0] +\n            Math.sqrt(\n              1 +\n                (position +\n                  negativeScrollableContentOffset -\n                  animatedSnapPoints.value[0])\n            ) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n      }\n\n      animatedPosition.value = clampedPosition;\n    },\n    onEnd: ({ state }, context) => {\n      gestureState.value = state;\n\n      if (\n        isExtendedByKeyboard.value &&\n        context.currentPosition >= animatedPosition.value\n      ) {\n        if (context.currentPosition > animatedPosition.value) {\n          animateToPoint(context.currentPosition, gestureVelocityY.value / 2);\n        }\n        return;\n      }\n\n      if (isExtendedByKeyboard.value) {\n        isExtendedByKeyboard.value = false;\n      }\n\n      const destinationPoint = snapPoint(\n        gestureTranslationY.value + context.currentPosition,\n        gestureVelocityY.value,\n        animatedSnapPoints.value\n      );\n\n      /**\n       * if destination point is the same as the current position,\n       * then no need to perform animation.\n       */\n      if (destinationPoint === animatedPosition.value) {\n        return;\n      }\n\n      if (\n        (scrollableContentOffsetY ? scrollableContentOffsetY.value : 0) > 0 &&\n        context.currentPosition ===\n          animatedSnapPoints.value[animatedSnapPoints.value.length - 1] &&\n        animatedPosition.value ===\n          animatedSnapPoints.value[animatedSnapPoints.value.length - 1]\n      ) {\n        return;\n      }\n\n      animateToPoint(destinationPoint, gestureVelocityY.value / 2);\n    },\n    onCancel: ({ state }) => {\n      gestureState.value = state;\n    },\n    onFail: ({ state }) => {\n      gestureState.value = state;\n    },\n    onFinish: ({ state }) => {\n      gestureState.value = state;\n    },\n  });\n\n  return [gestureHandler, gestureState, gestureTranslationY, gestureVelocityY];\n};\n"]}